'use client';

import React, { useState, useEffect, useMemo, useCallback, Fragment } from 'react';
import { format, addDays, startOfMonth, endOfMonth, eachDayOfInterval, isSameDay, isToday } from 'date-fns';
import { ja } from 'date-fns/locale';
import { createPortal } from 'react-dom';
import { useAuth } from './AuthProvider';
// ★★★ タイムライン共通ユーティリティをインポート ★★★
import {
  timeToPositionPercent,
  positionPercentToTime,
  generateTimeOptions,
  STATUS_COLORS,
  TIMELINE_CONFIG,
  capitalizeStatus,
  getCurrentTimePosition,
  Schedule as TimelineSchedule,
  Staff as TimelineStaff
} from './timeline/TimelineUtils';

// TimelineUtils からタイプをインポートしつつ、個人ページ固有の拡張を追加
interface Schedule extends TimelineSchedule {
  staffName: string;
  staffDepartment: string;
  staffGroup: string;
  empNo?: string;
  date?: string;
}

interface Staff extends TimelineStaff {
  // 個人ページでは基本タイプと同一
}

interface StaffDetails {
  id: number;
  empNo?: string;
  name: string;
  department: string;
  group: string;
  isActive: boolean;
  contract: {
    empNo: string;
    email: string;
    workingDays: string[];
    employmentType: 'REGULAR' | 'PART_TIME' | 'CONTRACT';
  } | null;
}

interface PresetSchedule {
  id: string;
  name: string;
  status: string;
  startTime: number; // 小数点時刻（例: 9.5 = 9:30）
  endTime: number;
  memo?: string;
  // 複数スケジュール対応（夜間勤務用）
  multiSchedules?: Array<{
    status: string;
    startTime: number;
    endTime: number;
    memo?: string;
  }>;
}

interface PresetButtonProps {
  preset: PresetSchedule;
  targetDate: Date;
  onAdd: (preset: PresetSchedule, date: Date) => void;
  disabled?: boolean;
}

// ユーティリティ関数は TimelineUtils から使用
const availableStatuses = ['online', 'remote', 'meeting', 'training', 'break', 'off', 'unplanned', 'night duty'];

const PersonalSchedulePage: React.FC = () => {
  const { user, loading: authLoading } = useAuth();
  const [selectedDate, setSelectedDate] = useState(new Date());
  const [schedules, setSchedules] = useState<Schedule[]>([]);
  const [currentStaff, setCurrentStaff] = useState<Staff | null>(null);
  const [staffDetails, setStaffDetails] = useState<StaffDetails | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [selectedDateForPreset, setSelectedDateForPreset] = useState<Date | null>(null);
  const [showPresetModal, setShowPresetModal] = useState(false);
  
  // ドラッグ&ドロップ関連の状態（メイン画面と同じ）
  const [dragInfo, setDragInfo] = useState<{
    date: Date;
    startX: number;
    currentX: number;
    rowRef: HTMLDivElement;
  } | null>(null);
  
  // ドラッグされたスケジュールの状態
  const [draggedSchedule, setDraggedSchedule] = useState<(Partial<Schedule> & { date?: string }) | null>(null);
  const [dragOffset, setDragOffset] = useState(0);
  const [selectedSchedule, setSelectedSchedule] = useState<{ schedule: Schedule; layer: string } | null>(null);
  
  // モーダル関連の状態
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [editingSchedule, setEditingSchedule] = useState<Schedule | null>(null);
  const [deletingScheduleId, setDeletingScheduleId] = useState<number | null>(null);
  
  // 表示モード状態管理（メイン画面と同様）
  const [viewMode, setViewMode] = useState<'normal' | 'compact'>(() => {
    if (typeof window !== 'undefined') {
      return (localStorage.getItem('callstatus-viewMode') as 'normal' | 'compact') || 'normal';
    }
    return 'normal';
  });
  
  // viewMode変更時のlocalStorage更新
  useEffect(() => {
    if (typeof window !== 'undefined') {
      localStorage.setItem('callstatus-viewMode', viewMode);
    }
  }, [viewMode]);
  
  // 行の高さを動的に決定（メイン画面と同様）
  const getRowHeight = useCallback(() => {
    return viewMode === 'compact' ? 'h-8' : 'h-[45px]';
  }, [viewMode]);
  
  // スケジュールバーの高さを動的に決定
  const getScheduleBarHeight = useCallback(() => {
    return viewMode === 'compact' ? 'h-4' : 'h-6';
  }, [viewMode]);
  
  // 編集権限チェック（メイン画面と同様）
  const canEdit = useCallback((scheduleStaffId: number): boolean => {
    return currentStaff?.id === scheduleStaffId;
  }, [currentStaff]);
  
  // モーダルオープン処理（メイン画面と同様）
  const handleOpenModal = useCallback((schedule: Schedule) => {
    setEditingSchedule(schedule);
    setDraggedSchedule(null);
    setIsModalOpen(true);
  }, []);
  
  

  // プリセット予定（後で管理画面から設定可能にする）
  const presetSchedules: PresetSchedule[] = [
    { id: 'remote-work', name: '在宅勤務', status: 'remote', startTime: 9, endTime: 18 },
    { 
      id: 'night-duty', 
      name: '夜間', 
      status: 'night duty', 
      startTime: 18, 
      endTime: 21,
      multiSchedules: [
        { status: 'night duty', startTime: 18, endTime: 21 },
        { status: 'off', startTime: 9, endTime: 13 },
        { status: 'break', startTime: 17, endTime: 18 }
      ]
    },
    { id: 'vacation', name: '休暇', status: 'off', startTime: 9, endTime: 18 },
    { id: 'morning-off', name: '午前休', status: 'off', startTime: 9, endTime: 13 },
    { id: 'afternoon-off', name: '午後休', status: 'off', startTime: 12, endTime: 18 },
    { id: 'early-leave', name: '早退', status: 'unplanned', startTime: 12, endTime: 18 },
  ];

  // 月間の日付リストを生成
  const monthDays = useMemo(() => {
    const start = startOfMonth(selectedDate);
    const end = endOfMonth(selectedDate);
    return eachDayOfInterval({ start, end });
  }, [selectedDate]);

  // 現在時刻
  const [currentTime, setCurrentTime] = useState(new Date());
  
  useEffect(() => {
    const timer = setInterval(() => {
      setCurrentTime(new Date());
    }, 60000); // 1分ごとに更新
    
    return () => clearInterval(timer);
  }, []);

  // 時間位置計算関数は TimelineUtils からインポート済み
  // timeToPositionPercent, positionPercentToTime を直接使用

  // APIベースURLを取得
  const getApiUrl = useCallback((): string => {
    if (typeof window !== 'undefined') {
      const hostname = window.location.hostname;
      if (hostname === 'localhost' || hostname === '127.0.0.1') {
        return 'http://localhost:3002';
      } else {
        return `http://${hostname}:3002`;
      }
    }
    return '';
  }, []);

  // 認証付きfetch
  const authenticatedFetch = useCallback(async (url: string, options: RequestInit = {}) => {
    const token = localStorage.getItem('access_token');
    return fetch(url, {
      ...options,
      headers: {
        ...options.headers,
        'Authorization': token ? `Bearer ${token}` : '',
        'Content-Type': 'application/json',
      },
    });
  }, []);

  // 現在のユーザーの社員情報を取得
  const fetchCurrentStaff = useCallback(async () => {
    if (!user?.email) {
      console.error('ユーザー情報が取得できません');
      return;
    }

    try {
      console.log('API URL:', getApiUrl());
      console.log('ユーザーメール:', user.email);
      
      const response = await authenticatedFetch(`${getApiUrl()}/api/staff`);
      console.log('スタッフAPI レスポンス状態:', response.status);
      
      if (response.ok) {
        const staffList: Staff[] = await response.json();
        console.log('取得したスタッフリスト:', staffList);
        
        // ユーザーメールから社員を検索
        let userStaff = staffList.find(staff => {
          // Contract テーブルのemailとマッチング
          return staff.name.includes(user.email.split('@')[0]) || 
                 staff.empNo === user.email.split('@')[0];
        });
        
        if (!userStaff && staffList.length > 0) {
          console.log('ユーザーに対応する社員が見つからないため、最初の社員を使用');
          userStaff = staffList[0];
        }
        
        if (userStaff) {
          console.log('選択された社員:', userStaff);
          setCurrentStaff(userStaff);
          // 詳細情報も取得
          await fetchStaffDetails(userStaff.id);
        } else {
          setError('対応する社員情報が見つかりません');
        }
      } else {
        const errorText = await response.text();
        console.error('スタッフAPI エラー:', response.status, errorText);
        setError(`社員情報の取得に失敗しました: ${response.status}`);
      }
    } catch (err) {
      console.error('社員情報の取得に失敗:', err);
      setError('社員情報の取得中にエラーが発生しました');
    }
  }, [user, getApiUrl, authenticatedFetch]);

  // スタッフ詳細情報を取得
  const fetchStaffDetails = useCallback(async (staffId: number) => {
    try {
      const response = await authenticatedFetch(`${getApiUrl()}/api/staff/${staffId}/details`);
      if (response.ok) {
        const details: StaffDetails = await response.json();
        console.log('取得した詳細情報:', details);
        setStaffDetails(details);
      } else {
        console.error('詳細情報の取得に失敗:', response.status);
      }
    } catch (err) {
      console.error('詳細情報の取得エラー:', err);
    }
  }, [getApiUrl, authenticatedFetch]);

  // スケジュールデータを取得
  const fetchSchedules = useCallback(async () => {
    if (!currentStaff) {
      console.log('currentStaffが設定されていないため、スケジュール取得をスキップ');
      return;
    }

    console.log('スケジュール取得開始:', {
      currentStaff: currentStaff.name,
      staffId: currentStaff.id,
      monthDays: monthDays.length
    });

    setLoading(true);
    setError(null);

    try {
      const promises = monthDays.map(async (day) => {
        const dateStr = format(day, 'yyyy-MM-dd');
        const url = `${getApiUrl()}/api/schedules/unified?date=${dateStr}&includeMasking=false`;
        console.log(`API呼び出し: ${url}`);
        
        const response = await authenticatedFetch(url);
        
        if (response.ok) {
          const data = await response.json();
          console.log(`${dateStr}のレスポンス:`, data);
          
          const filteredSchedules = data.schedules?.filter((schedule: Schedule) => 
            schedule.staffId === currentStaff.id
          ).map((schedule: Schedule) => ({
            ...schedule,
            _fetchDate: dateStr // スケジュールがどの日付から取得されたかを記録
          })) || [];
          
          console.log(`${dateStr}のフィルター後スケジュール:`, filteredSchedules);
          return filteredSchedules;
        } else {
          console.error(`${dateStr}のAPI呼び出し失敗:`, response.status);
          return [];
        }
      });

      const results = await Promise.all(promises);
      const allSchedules = results.flat();
      console.log('全スケジュール取得完了:', {
        総件数: allSchedules.length,
        スケジュール: allSchedules
      });
      
      // デバッグ: 最初のスケジュールの構造を確認
      if (allSchedules.length > 0) {
        console.log('=== スケジュールデータ構造確認 ===');
        console.log('最初のスケジュール:', allSchedules[0]);
        console.log('start type:', typeof allSchedules[0].start);
        console.log('end type:', typeof allSchedules[0].end);
        console.log('staffId type:', typeof allSchedules[0].staffId);
      }
      
      setSchedules(allSchedules);
    } catch (err) {
      console.error('スケジュールの取得に失敗:', err);
      setError('スケジュールの取得に失敗しました');
    } finally {
      setLoading(false);
    }
  }, [currentStaff, monthDays, getApiUrl, authenticatedFetch]);

  // ドラッグオーバー処理
  const handleDragOver = useCallback((e: React.DragEvent) => {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
  }, []);

  // ドロップ処理（スケジュール時間変更）
  const handleDrop = useCallback(async (e: React.DragEvent, targetDate: Date) => {
    e.preventDefault();
    
    if (!draggedSchedule || !currentStaff) return;
    
    const rect = e.currentTarget.getBoundingClientRect();
    const dropX = e.clientX - rect.left - dragOffset;
    const dropPosition = (dropX / rect.width) * 100;
    const newStartTime = positionPercentToTime(dropPosition);
    
    const duration = (typeof draggedSchedule.end === 'number' ? draggedSchedule.end : 0) - 
                    (typeof draggedSchedule.start === 'number' ? draggedSchedule.start : 0);
    const newEndTime = newStartTime + duration;
    
    if (newEndTime > 21) {
      alert('21:00を超える時間は設定できません');
      return;
    }
    
    try {
      const response = await fetch(`${getApiUrl()}/api/schedules/${draggedSchedule.id}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          start: newStartTime,
          end: newEndTime,
          date: format(targetDate, 'yyyy-MM-dd')
        })
      });
      
      if (response.ok) {
        // スケジュール更新成功後はページをリロード
        window.location.reload();
      } else {
        alert('スケジュールの更新に失敗しました');
      }
    } catch (error) {
      console.error('スケジュール更新エラー:', error);
      alert('スケジュールの更新に失敗しました');
    } finally {
      setDraggedSchedule(null);
      setDragOffset(0);
    }
  }, [draggedSchedule, dragOffset, currentStaff, fetchSchedules]);

  // 初期化処理
  useEffect(() => {
    if (!authLoading && user) {
      fetchCurrentStaff();
    }
  }, [authLoading, user, fetchCurrentStaff]);

  useEffect(() => {
    if (currentStaff) {
      fetchSchedules();
    }
  }, [currentStaff]);

  // プリセット予定を追加
  const addPresetSchedule = useCallback(async (preset: PresetSchedule, targetDate: Date) => {
    if (!currentStaff) {
      console.error('社員情報が設定されていません');
      setError('社員情報が設定されていません');
      return;
    }

    const dateStr = format(targetDate, 'yyyy-MM-dd');
    console.log('プリセット予定追加:', {
      preset,
      targetDate: dateStr,
      currentStaff: currentStaff.name
    });
    
    try {
      // 複数スケジュール対応
      const schedulesToAdd = preset.multiSchedules || [{
        status: preset.status,
        startTime: preset.startTime,
        endTime: preset.endTime,
        memo: preset.memo
      }];

      // 複数のスケジュールを順次追加
      for (const scheduleData of schedulesToAdd) {
        const newSchedule = {
          staffId: currentStaff.id,
          status: scheduleData.status,
          start: scheduleData.startTime,
          end: scheduleData.endTime,
          memo: scheduleData.memo || '',
          date: dateStr,
        };

        console.log('送信データ:', newSchedule);
        const url = `${getApiUrl()}/api/schedules`;
        console.log('API URL:', url);

        const response = await authenticatedFetch(url, {
          method: 'POST',
          body: JSON.stringify(newSchedule),
        });

        console.log('追加レスポンス:', response.status);

        if (!response.ok) {
          const errorData = await response.json();
          console.error('追加エラー:', errorData);
          setError(errorData.message || 'スケジュールの追加に失敗しました');
          return;
        }
      }

      // 全て成功した場合
      console.log('全プリセット予定追加成功');
      
      // スケジュールを再取得
      await fetchSchedules();
      
      // 成功メッセージ
      setError(null);
      console.log('プリセット予定を追加しました');
    } catch (err) {
      console.error('スケジュール追加エラー:', err);
      setError('スケジュールの追加に失敗しました');
    }
  }, [currentStaff, getApiUrl, authenticatedFetch, fetchSchedules]);

  // ドラッグ開始ハンドラー（修正版）
  const handleTimelineMouseDown = useCallback((e: React.MouseEvent, targetDate: Date) => {
    // 右クリックの場合は無視
    if (e.button !== 0) return;
    
    console.log('=== ドラッグ開始 ===');
    console.log('targetDate:', targetDate);
    console.log('currentStaff:', currentStaff);
    
    const rect = e.currentTarget.getBoundingClientRect();
    const startX = e.clientX - rect.left;
    
    // ローカル変数でドラッグ情報を管理
    let currentX = startX;
    const rowElement = e.currentTarget as HTMLDivElement;
    
    // 初期状態を設定
    setDragInfo({
      date: targetDate,
      startX,
      currentX: startX,
      rowRef: rowElement,
    });
    
    // ドキュメント全体でマウスイベントをキャプチャ
    const handleMouseMove = (moveEvent: MouseEvent) => {
      currentX = moveEvent.clientX - rect.left;
      
      // ドラッグインジケーター用に状態更新
      setDragInfo({
        date: targetDate,
        startX,
        currentX,
        rowRef: rowElement,
      });
    };
    
    const handleMouseUp = () => {
      console.log('=== ドラッグ終了 ===');
      console.log('startX:', startX, 'currentX:', currentX);
      console.log('ドラッグ距離:', Math.abs(currentX - startX));
      
      if (Math.abs(currentX - startX) > 5) {
        // ドラッグが発生した場合、新規スケジュール作成
        const leftX = Math.min(startX, currentX);
        const rightX = Math.max(startX, currentX);
        
        console.log('leftX:', leftX, 'rightX:', rightX, 'rect.width:', rect.width);
        
        // 13時間分（8:00-21:00）を52マス（15分×4マス/時間）に分割
        const TIMELINE_HOURS = 13; // 21 - 8
        const QUARTERS_PER_HOUR = 4;
        const TOTAL_QUARTERS = TIMELINE_HOURS * QUARTERS_PER_HOUR; // 52マス
        
        // X座標を15分単位のマス数に変換
        const leftQuarter = (leftX / rect.width) * TOTAL_QUARTERS;
        const rightQuarter = (rightX / rect.width) * TOTAL_QUARTERS;
        
        // 最近傍の15分単位にスナップ
        const snappedLeftQuarter = Math.round(leftQuarter);
        const snappedRightQuarter = Math.round(rightQuarter);
        
        // マス数を時刻に変換
        const startTime = 8 + (snappedLeftQuarter / QUARTERS_PER_HOUR);
        const endTime = 8 + (snappedRightQuarter / QUARTERS_PER_HOUR);
        
        console.log('計算結果 - startTime:', startTime, 'endTime:', endTime);
        
        // 最小15分間の制約
        if (endTime - startTime >= 0.25) {
          const draggedData: Partial<Schedule> & { date?: string } = {
            staffId: currentStaff?.id,
            status: 'online',
            start: startTime,
            end: endTime,
            memo: '',
            staffName: currentStaff?.name || '',
            staffDepartment: currentStaff?.department || '',
            staffGroup: currentStaff?.group || '',
            date: format(targetDate, 'yyyy-MM-dd'),
          };
          
          console.log('=== ドラッグ&ドロップ新規予定作成 ===');
          console.log('対象日付:', format(targetDate, 'yyyy-MM-dd'));
          console.log('時間:', `${startTime} - ${endTime}`);
          console.log('作成データ:', draggedData);
          
          setDraggedSchedule(draggedData);
          console.log('モーダルを開く: setIsModalOpen(true)');
          setIsModalOpen(true);
          setEditingSchedule(null);
        } else {
          console.log('最小時間制約により作成をスキップ');
        }
      } else {
        console.log('ドラッグ距離が不足のため作成をスキップ');
      }
      
      // クリーンアップ
      setDragInfo(null);
      document.removeEventListener('mousemove', handleMouseMove);
      document.removeEventListener('mouseup', handleMouseUp);
    };
    
    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);
  }, [currentStaff]);

  // スケジュール保存ハンドラー（メイン画面と同じ）
  const handleSaveSchedule = useCallback(async (scheduleData: any) => {
    console.log('スケジュール保存:', scheduleData);
    
    try {
      const isEditing = scheduleData.id !== undefined;
      
      if (isEditing) {
        // 編集の場合
        const updateData = {
          status: scheduleData.status,
          start: scheduleData.start,
          end: scheduleData.end,
          memo: scheduleData.memo || '',
        };
        
        const response = await authenticatedFetch(`${getApiUrl()}/api/schedules/${scheduleData.id}`, {
          method: 'PATCH',
          body: JSON.stringify(updateData),
        });
        
        if (response.ok) {
          console.log('スケジュール更新成功');
          await fetchSchedules();
          setIsModalOpen(false);
          setEditingSchedule(null);
        } else {
          const errorData = await response.json();
          setError(errorData.message || 'スケジュールの更新に失敗しました');
        }
      } else {
        // 新規作成の場合
        const createData = {
          staffId: scheduleData.staffId || currentStaff?.id,
          status: scheduleData.status,
          start: typeof scheduleData.start === 'number' ? scheduleData.start : scheduleData.start,
          end: typeof scheduleData.end === 'number' ? scheduleData.end : scheduleData.end,
          memo: scheduleData.memo || '',
          date: scheduleData.date || format(new Date(), 'yyyy-MM-dd'),
        };
        
        const response = await authenticatedFetch(`${getApiUrl()}/api/schedules`, {
          method: 'POST',
          body: JSON.stringify(createData),
        });
        
        if (response.ok) {
          console.log('スケジュール作成成功');
          await fetchSchedules();
          setIsModalOpen(false);
          setDraggedSchedule(null);
          setEditingSchedule(null);
        } else {
          const errorData = await response.json();
          setError(errorData.message || 'スケジュールの作成に失敗しました');
        }
      }
    } catch (err) {
      console.error('スケジュール保存エラー:', err);
      setError('スケジュールの保存中にエラーが発生しました');
    }
  }, [currentStaff, getApiUrl, authenticatedFetch, fetchSchedules]);

  // スケジュール削除ハンドラー
  const handleDeleteSchedule = useCallback(async (scheduleId: number) => {
    console.log('スケジュール削除:', scheduleId);
    
    try {
      const response = await authenticatedFetch(`${getApiUrl()}/api/schedules/${scheduleId}`, {
        method: 'DELETE',
      });
      
      if (response.ok) {
        console.log('スケジュール削除成功');
        await fetchSchedules();
        setDeletingScheduleId(null);
      } else {
        const errorData = await response.json();
        setError(errorData.message || 'スケジュールの削除に失敗しました');
      }
    } catch (err) {
      console.error('スケジュール削除エラー:', err);
      setError('スケジュールの削除中にエラーが発生しました');
    }
  }, [getApiUrl, authenticatedFetch, fetchSchedules]);

  // 月変更ハンドラー
  const handleMonthChange = useCallback((direction: 'prev' | 'next') => {
    setSelectedDate(prev => {
      const newDate = new Date(prev);
      if (direction === 'prev') {
        newDate.setMonth(prev.getMonth() - 1);
      } else {
        newDate.setMonth(prev.getMonth() + 1);
      }
      return newDate;
    });
  }, []);

  // viewMode変更時にlocalStorageに保存
  const toggleViewMode = () => {
    const newMode = viewMode === 'normal' ? 'compact' : 'normal';
    setViewMode(newMode);
    if (typeof window !== 'undefined') {
      localStorage.setItem('callstatus-viewMode', newMode);
    }
  };

  // ステータス色は TimelineUtils.STATUS_COLORS からインポート済み
  const getStatusColor = useCallback((status: string): string => {
    return STATUS_COLORS[status] || '#6b7280';
  }, []);

  // 時刻文字列の変換
  const formatTime = useCallback((decimalTime: number): string => {
    const hours = Math.floor(decimalTime);
    const minutes = Math.round((decimalTime - hours) * 60);
    return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
  }, []);

  if (authLoading || loading) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="animate-spin rounded-full h-32 w-32 border-b-2 border-blue-500"></div>
      </div>
    );
  }

  if (!user) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="text-red-500">ログインが必要です</div>
      </div>
    );
  }

  if (!currentStaff) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="text-red-500">社員情報が見つかりません</div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gray-50">
      {/* メイン画面と同じ認証ヘッダー */}
      <div className="bg-white shadow-sm border-b border-gray-200 px-6 py-3 flex justify-between items-center">
        <h1 className="text-lg font-semibold text-gray-900">
          個人スケジュール
        </h1>
        <div className="flex items-center space-x-4">
          <a
            href="/"
            className="text-sm bg-blue-100 hover:bg-blue-200 text-blue-800 px-3 py-1 rounded border border-blue-300 transition-colors"
          >
            📊 メイン画面
          </a>
        </div>
      </div>

      <div className={`container mx-auto p-2 font-sans ${viewMode === 'compact' ? 'compact-mode' : ''}`}>
        {/* メイン画面と同じ形式のヘッダー */}
        <header className="mb-2 flex justify-between items-center">
          <div className="flex items-center space-x-3">
            <div className="inline-flex rounded-md shadow-sm" role="group">
              <button 
                type="button" 
                onClick={() => handleMonthChange('prev')} 
                className="px-2 py-1 text-xs font-medium text-gray-900 bg-white border border-gray-200 rounded-l-lg hover:bg-gray-100 h-7"
              >
                &lt;
              </button>
              <button 
                type="button" 
                className="px-2 py-1 text-xs font-medium text-gray-900 bg-white border-t border-b border-gray-200 hover:bg-gray-100 h-7"
              >
                今月
              </button>
              <button 
                type="button" 
                onClick={() => handleMonthChange('next')} 
                className="px-2 py-1 text-xs font-medium text-gray-900 bg-white border border-gray-200 rounded-r-lg hover:bg-gray-100 h-7"
              >
                &gt;
              </button>
            </div>
            <div className="text-lg font-semibold text-gray-900">
              {format(selectedDate, 'yyyy年M月d日(E)', { locale: ja })}
            </div>
          </div>

          <div className="flex items-center space-x-2">
            <button 
              onClick={toggleViewMode}
              title={`表示密度: ${viewMode === 'normal' ? '標準' : 'コンパクト'}`}
              className={`toggle-switch ${viewMode === 'compact' ? 'active' : ''}`}
            >
              <div className={`toggle-thumb ${viewMode === 'compact' ? 'active' : ''}`}></div>
            </button>
          </div>
        </header>

        {/* 個人情報表示 - メイン画面のフィルター部分と同じ構成 */}
        <div className="mb-2 p-2 bg-gray-50 rounded-lg">
          {staffDetails && (
            <div className="space-y-1">
              <div className="text-sm text-gray-700 flex flex-wrap items-center gap-4 ml-2">
                <span className="flex items-center gap-1">
                  <span className="font-bold">名前：</span>
                  <span className="px-2 py-1 bg-blue-50 text-blue-700 rounded text-sm">{currentStaff.name}</span>
                </span>
                <span className="flex items-center gap-1">
                  <span className="font-bold">社員番号：</span>
                  <span className="px-2 py-1 bg-blue-50 text-blue-700 rounded text-sm">{staffDetails.empNo || '未設定'}</span>
                </span>
                <span className="flex items-center gap-1">
                  <span className="font-bold">部署：</span>
                  <span className="px-2 py-1 bg-blue-50 text-blue-700 rounded text-sm">{staffDetails.department}</span>
                </span>
                <span className="flex items-center gap-1">
                  <span className="font-bold">グループ：</span>
                  <span className="px-2 py-1 bg-blue-50 text-blue-700 rounded text-sm">{staffDetails.group}</span>
                </span>
              </div>
              {/* 契約勤務時間（横並びで表示） */}
              {staffDetails.contract && staffDetails.contract.workingDays.length > 0 && (
                <div className="text-sm text-gray-600 flex items-center gap-2 flex-wrap ml-2">
                  <span className="font-bold">勤務時間：</span>
                  {staffDetails.contract.workingDays.map((day, index) => (
                    <span key={index} className="px-2 py-1 bg-blue-50 text-blue-700 rounded text-sm">
                      {day}
                    </span>
                  ))}
                </div>
              )}
            </div>
          )}
        </div>

        {/* エラー表示 */}
        {error && (
          <div className="bg-red-50 border border-red-200 rounded-lg p-4 mb-6">
            <div className="text-red-800">{error}</div>
          </div>
        )}

        {/* プリセット予定ボタン */}
        <div className="sticky top-0 z-20 bg-white rounded-lg shadow-md p-6 mb-6 border-b">
          <h3 className="text-lg font-semibold text-gray-900 mb-4">クイック予定追加</h3>
          <div className="mb-4 text-sm text-gray-600">
            📌 今日の予定を追加、または下の日付をクリックして特定の日に追加
          </div>
          <div className="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-7 gap-3">
            {presetSchedules.map((preset) => (
              <button
                key={preset.id}
                onClick={() => {
                  const targetDate = selectedDateForPreset || new Date();
                  addPresetSchedule(preset, targetDate);
                }}
                className="px-2 py-1 text-xs border border-gray-200 rounded hover:bg-gray-50 transition-colors"
                style={{ borderLeftColor: getStatusColor(preset.status), borderLeftWidth: '4px' }}
              >
                <div className="font-medium text-gray-900 text-center whitespace-pre-line text-xs">
                  {preset.multiSchedules ? (
                    `${preset.name}\n複数時間帯`
                  ) : (
                    `${preset.name}\n${formatTime(preset.startTime)}-${formatTime(preset.endTime)}`
                  )}
                </div>
              </button>
            ))}
          </div>
          {selectedDateForPreset && (
            <div className="mt-3 p-2 bg-blue-50 rounded border border-blue-200">
              <div className="text-sm text-blue-800">
                📅 {format(selectedDateForPreset, 'M月d日(E)', { locale: ja })} に追加します
                <button
                  onClick={() => setSelectedDateForPreset(null)}
                  className="ml-2 text-blue-600 hover:text-blue-800 underline"
                >
                  キャンセル
                </button>
              </div>
            </div>
          )}
        </div>

        {/* 月間ガントチャート（メイン画面と同じ構造） */}
        <div className="bg-white rounded-lg shadow-sm overflow-hidden">
          <div className="p-6 border-b border-gray-200">
            <h3 className="text-lg font-semibold text-gray-900">月間スケジュール</h3>
          </div>
          
          <div className="bg-white shadow rounded-lg relative">
            <div className="flex">
              {/* 左列: 日付列（固定） */}
              <div className="min-w-fit max-w-[120px] sticky left-0 z-20 bg-white border-r border-gray-200">
                {/* 上部スクロールバー用のスペーサー */}
                <div className="h-[17px] bg-gray-50 border-b"></div>
                {/* ヘッダー行 - 時刻行と同じ高さに調整 */}
                <div className="px-2 py-2 bg-gray-100 font-bold text-gray-600 text-sm text-center border-b whitespace-nowrap">日付</div>
                {/* 日付行 */}
                {monthDays.map((day) => (
                  <div key={day.toISOString()} className={`px-2 text-sm font-medium whitespace-nowrap h-[${viewMode === 'compact' ? '32' : '45'}px] hover:bg-gray-50 flex items-center border-b`}>
                    {format(day, 'M/d E', { locale: ja })}
                  </div>
                ))}
              </div>
              
              {/* 右列: ガントチャート */}
              <div className="flex-1 flex flex-col">
                {/* 上部スクロールバー */}
                <div className="overflow-x-auto border-b">
                  <div className="min-w-[1300px] h-[17px]"></div>
                </div>
                
                {/* 時間ヘッダー（通常表示） */}
                <div className="bg-gray-100 border-b overflow-hidden">
                  <div className="min-w-[1300px]">
                    <div className="flex font-bold text-sm">
                      {Array.from({ length: 13 }).map((_, i) => {
                        const hour = 8 + i;
                        const isEarlyOrNight = hour === 8 || hour >= 18; // 8:00と18:00以降を特別扱い
                        const width = `${(4 / 52) * 100}%`; // 4マス分 = 1時間分の幅
                        return (
                          <div 
                            key={hour} 
                            className={`text-left pl-2 border-r py-2 whitespace-nowrap ${isEarlyOrNight ? 'bg-blue-50' : ''}`}
                            style={{ width }}
                            title={`${hour}:00 ${isEarlyOrNight ? '(特別時間帯)' : ''}`}
                          >
                            {hour}:00
                          </div>
                        );
                      })}
                    </div>
                    </div>
                  </div>
                </div>
                
                {/* メインコンテンツ */}
                <div className="flex-1 overflow-x-auto">
                  <div className="min-w-[1300px] relative">
                    {/* 15分単位の目盛り（全体） */}
                    {(() => {
                      const markers = [];
                      for (let hour = 8; hour <= 21; hour++) {
                        for (let minute = 0; minute < 60; minute += 15) {
                          if (hour === 21 && minute > 0) break;
                          const time = hour + minute / 60;
                          const position = timeToPositionPercent(time);
                          const timeString = `${hour}:${String(minute).padStart(2, '0')}`;
                          
                          markers.push(
                            <div
                              key={`${hour}-${minute}`}
                              className="absolute top-0 bottom-0 w-0.5 border-l border-gray-300 z-5 opacity-50"
                              style={{ left: `${position}%` }}
                              title={timeString}
                            />
                          );
                        }
                      }
                      return markers;
                    })()}
                    
                    {/* 早朝エリア（8:00-9:00）の背景強調 */}
                    <div className="absolute top-0 bottom-0 bg-blue-50 opacity-30 z-10" 
                         style={{ left: `0%`, width: `${((9-8)*4)/52*100}%` }} 
                         title="早朝時間帯（8:00-9:00）">
                    </div>
                    
                    {/* 夜間エリア（18:00-21:00）の背景強調 */}
                    <div className="absolute top-0 bottom-0 bg-blue-50 opacity-30 z-10" 
                         style={{ left: `${((18-8)*4)/52*100}%`, width: `${((21-18)*4)/52*100}%` }} 
                         title="夜間時間帯（18:00-21:00）">
                    </div>

                    {/* 各日の行 */}
                    {monthDays.map((day) => {
                      const daySchedules = schedules.filter(schedule => {
                        const dayDateStr = format(day, 'yyyy-MM-dd');
                        return schedule._fetchDate === dayDateStr;
                      });
                      
                      const isCurrentDay = isToday(day);
                      const getCurrentTimePosition = () => {
                        if (!isCurrentDay) return null;
                        const currentDecimalHour = currentTime.getHours() + currentTime.getMinutes() / 60;
                        if (currentDecimalHour < 8 || currentDecimalHour >= 21) return null;
                        return timeToPositionPercent(currentDecimalHour);
                      };
                      const currentTimePosition = getCurrentTimePosition();
                      
                      return (
                        <div key={day.getTime()} 
                             className={`relative border-b border-gray-100 hover:bg-gray-50 ${getRowHeight()}`}
                             onMouseDown={(e) => handleTimelineMouseDown(e, day)}
                             onDrop={(e) => handleDrop(e, day)}
                             onDragOver={handleDragOver}>
                          
                          {/* 現在時刻インジケーター */}
                          {currentTimePosition !== null && (
                            <div className="absolute top-0 bottom-0 w-0.5 bg-red-500 z-30" 
                                 style={{ left: `${currentTimePosition}%` }} 
                                 title={`現在時刻: ${currentTime.getHours()}:${String(currentTime.getMinutes()).padStart(2, '0')}`}>
                            </div>
                          )}

                      {/* ドラッグインジケーター（メイン画面と同じ） */}
                      {dragInfo && isSameDay(dragInfo.date, day) && (
                        (() => {
                          const leftX = Math.min(dragInfo.startX, dragInfo.currentX);
                          const rightX = Math.max(dragInfo.startX, dragInfo.currentX);
                          const width = rightX - leftX;
                          
                          if (width < 5) return null; // 最小幅チェック
                          
                          const leftPercent = (leftX / dragInfo.rowRef.clientWidth) * 100;
                          const widthPercent = (width / dragInfo.rowRef.clientWidth) * 100;
                          
                          return (
                            <div
                              className="absolute bg-blue-400 opacity-50 border-2 border-blue-600 rounded z-20"
                              style={{
                                left: `${leftPercent}%`,
                                width: `${widthPercent}%`,
                                top: '50%',
                                transform: 'translateY(-50%)',
                                height: viewMode === 'compact' ? '16px' : '24px',
                              }}
                            />
                          );
                        })()
                      )}

                      {/* スケジュールバー（メイン画面と同じスタイル） */}
                      {daySchedules.map((schedule, index) => {
                        let startHour: number;
                        let endHour: number;
                        
                        // デバッグ: schedule.startの型を確認
                        if (format(day, 'yyyy-MM-dd') === '2025-06-25' && schedule.staffId === 214) {
                          console.log('schedule.start type:', typeof schedule.start, 'value:', schedule.start);
                          console.log('schedule.end type:', typeof schedule.end, 'value:', schedule.end);
                          console.log('full schedule:', schedule);
                        }
                        
                        if (typeof schedule.start === 'number') {
                          startHour = schedule.start;
                          endHour = schedule.end as number;
                        } else {
                          const startDate = new Date(schedule.start as Date);
                          const endDate = new Date(schedule.end as Date);
                          startHour = startDate.getHours() + startDate.getMinutes() / 60;
                          endHour = endDate.getHours() + endDate.getMinutes() / 60;
                        }

                        const startPosition = timeToPositionPercent(startHour);
                        const endPosition = timeToPositionPercent(endHour);
                        const barWidth = endPosition - startPosition;
                        const isContract = schedule.layer === 'contract';
                        const isHistorical = schedule.layer === 'historical' || schedule.isHistorical;
                        
                        // デバッグ: 表示位置の計算を確認
                        if (format(day, 'yyyy-MM-dd') === '2025-06-25' && schedule.staffId === 214) {
                          console.log(`Schedule bar計算:`, {
                            startHour,
                            endHour,
                            startPosition,
                            endPosition,
                            barWidth,
                            isContract,
                            isHistorical
                          });
                        }

                        return (
                          <div
                            key={`${schedule.id}-${schedule.layer}-${index}`}
                            className={`schedule-block absolute ${getScheduleBarHeight()} rounded text-white text-xs flex items-center justify-between px-2 group ${
                              isContract || isHistorical ? 'cursor-default' : 'cursor-pointer hover:opacity-80'
                            } ${
                              isHistorical ? 'border-2 border-dashed border-gray-400' : ''
                            } ${
                              // 選択状態のハイライト（メイン画面と同様）
                              selectedSchedule && 
                              selectedSchedule.schedule.id === schedule.id && 
                              selectedSchedule.layer === (schedule.layer || 'adjustment')
                                ? 'ring-2 ring-yellow-400 ring-offset-1'
                                : ''
                            }`}
                            draggable={!isContract && !isHistorical && canEdit(schedule.staffId)}
                            onDragStart={(e) => {
                              if (!isContract && !isHistorical && canEdit(schedule.staffId)) {
                                const rect = e.currentTarget.getBoundingClientRect();
                                const clickX = e.clientX - rect.left;
                                setDragOffset(clickX);
                                setDraggedSchedule({
                                  ...schedule,
                                  date: format(day, 'yyyy-MM-dd')
                                });
                                e.dataTransfer.effectAllowed = 'move';
                              }
                            }}
                            onDragEnd={() => {
                              setDraggedSchedule(null);
                              setDragOffset(0);
                            }}
                            style={{
                              left: `${startPosition}%`,
                              width: `${barWidth}%`,
                              top: '50%',
                              transform: 'translateY(-50%)',
                              backgroundColor: getStatusColor(schedule.status),
                              opacity: isContract ? 0.5 : isHistorical ? 0.8 : 1,
                              backgroundImage: isContract 
                                ? 'repeating-linear-gradient(45deg, transparent, transparent 2px, rgba(255,255,255,0.3) 2px, rgba(255,255,255,0.3) 4px)' 
                                : isHistorical 
                                ? 'repeating-linear-gradient(45deg, transparent, transparent 10px, rgba(255,255,255,0.15) 10px, rgba(255,255,255,0.15) 20px)'
                                : 'none',
                              zIndex: isContract ? 10 : isHistorical ? 15 : 30,
                            }}
                            onClick={(e) => {
                              e.stopPropagation();
                              if (!isContract && !isHistorical && canEdit(schedule.staffId)) {
                                const scheduleLayer = schedule.layer || 'adjustment';
                                const currentSelection = selectedSchedule;
                                
                                if (currentSelection && 
                                    currentSelection.schedule.id === schedule.id && 
                                    currentSelection.layer === scheduleLayer) {
                                  // 同じ予定を再クリック → 編集モーダルを開く
                                  handleOpenModal(schedule);
                                  setSelectedSchedule(null);
                                } else {
                                  // 異なる予定をクリック → 選択状態にする
                                  setSelectedSchedule({ schedule, layer: scheduleLayer });
                                }
                              }
                            }}
                          >
                            <span className="truncate">
                              {capitalizeStatus(schedule.status)}
                              {schedule.memo && (
                                <span className="ml-1 text-yellow-200">📝</span>
                              )}
                            </span>
                            {!isContract && !isHistorical && (
                              <button 
                                onClick={(e) => { 
                                  e.stopPropagation(); 
                                  setDeletingScheduleId(schedule.id); 
                                }} 
                                className="text-white hover:text-red-200 ml-2 opacity-0 group-hover:opacity-100 transition-opacity"
                              >
                                ×
                              </button>
                            )}
                          </div>
                        );
                      })}
                      </div>
                    );
                  })}
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>

        {/* メイン画面に戻るリンク */}
        <div className="mt-6 text-center">
          <a
            href="/"
            className="inline-flex items-center px-4 py-2 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50"
          >
            メイン画面に戻る
          </a>
        </div>

        {/* モーダル */}
        <ScheduleModal 
          isOpen={isModalOpen} 
          onClose={() => {
            setIsModalOpen(false);
            setDraggedSchedule(null);
            setEditingSchedule(null);
          }} 
          staffList={currentStaff ? [currentStaff] : []} 
          onSave={handleSaveSchedule} 
          scheduleToEdit={editingSchedule} 
          initialData={draggedSchedule || undefined} 
        />
        <ConfirmationModal 
          isOpen={deletingScheduleId !== null} 
          onClose={() => setDeletingScheduleId(null)} 
          onConfirm={() => { if (deletingScheduleId) handleDeleteSchedule(deletingScheduleId); }} 
          message="この予定を削除しますか？" 
        />
      </div>
    </div>
  );
};

// ScheduleModal コンポーネント
const ScheduleModal = ({ isOpen, onClose, staffList, onSave, scheduleToEdit, initialData }: { 
  isOpen: boolean; 
  onClose: () => void; 
  staffList: Staff[]; 
  onSave: (data: any) => void;
  scheduleToEdit: Schedule | null;
  initialData?: Partial<Schedule> & { date?: string };
}) => {
  const [selectedStaff, setSelectedStaff] = useState<number | ''>('');
  const [selectedStatus, setSelectedStatus] = useState<string>('');
  const [startTime, setStartTime] = useState<number>(9);
  const [endTime, setEndTime] = useState<number>(18);
  const [memo, setMemo] = useState<string>('');

  const timeOptions = useMemo(() => generateTimeOptions(8, 21), []);

  useEffect(() => {
    if (isOpen) {
      console.log('=== ScheduleModal useEffect ===');
      console.log('scheduleToEdit:', scheduleToEdit);
      console.log('initialData:', initialData);
      console.log('staffList:', staffList);
      
      if (scheduleToEdit) {
        // 編集モード
        console.log('編集モードでモーダル初期化');
        setSelectedStaff(scheduleToEdit.staffId);
        setSelectedStatus(scheduleToEdit.status);
        setStartTime(typeof scheduleToEdit.start === 'number' ? scheduleToEdit.start : 9);
        setEndTime(typeof scheduleToEdit.end === 'number' ? scheduleToEdit.end : 18);
        setMemo(scheduleToEdit.memo || '');
      } else if (initialData) {
        // ドラッグ&ドロップまたはプリセットからの新規作成
        console.log('initialDataを使用してモーダル初期化');
        console.log('設定値 - staffId:', initialData.staffId, 'status:', initialData.status, 'start:', initialData.start, 'end:', initialData.end);
        setSelectedStaff(initialData.staffId || (staffList.length > 0 ? staffList[0].id : ''));
        setSelectedStatus(initialData.status || 'online');
        setStartTime(typeof initialData.start === 'number' ? initialData.start : 9);
        setEndTime(typeof initialData.end === 'number' ? initialData.end : 18);
        setMemo(initialData.memo || '');
      } else {
        // 空の新規作成
        console.log('空の新規作成でモーダル初期化');
        setSelectedStaff(staffList.length > 0 ? staffList[0].id : '');
        setSelectedStatus('online');
        setStartTime(9);
        setEndTime(18);
        setMemo('');
      }
    }
  }, [isOpen, scheduleToEdit, initialData, staffList]);

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    
    console.log('=== ScheduleModal handleSubmit ===');
    console.log('フォーム値 - selectedStaff:', selectedStaff, 'selectedStatus:', selectedStatus);
    console.log('フォーム値 - startTime:', startTime, 'endTime:', endTime, 'memo:', memo);
    console.log('initialData?.date:', initialData?.date);
    
    if (!selectedStaff || !selectedStatus) {
      console.log('バリデーションエラー: スタッフまたはステータスが未選択');
      alert('スタッフとステータスを選択してください');
      return;
    }
    
    if (startTime >= endTime) {
      console.log('バリデーションエラー: 開始時刻が終了時刻以降');
      alert('開始時刻は終了時刻より前に設定してください');
      return;
    }

    const scheduleData = {
      id: scheduleToEdit?.id,
      staffId: Number(selectedStaff),
      status: selectedStatus,
      start: startTime,
      end: endTime,
      memo: memo,
      date: initialData?.date, // ドラッグ作成時の日付情報を含める
    };

    console.log('送信するscheduleData:', scheduleData);
    onSave(scheduleData);
  };

  if (!isOpen) {
    console.log('ScheduleModal: isOpen=false なので表示しない');
    return null;
  }
  
  console.log('ScheduleModal: 表示中 isOpen=true');

  return createPortal(
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <div className="bg-white rounded-lg p-6 w-full max-w-md">
        <h2 className="text-lg font-bold mb-4">
          {scheduleToEdit ? 'スケジュール編集' : 'スケジュール追加'}
        </h2>
        
        <form onSubmit={handleSubmit} className="space-y-4">
          {/* スタッフ選択 */}
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              スタッフ
            </label>
            <select
              value={selectedStaff}
              onChange={(e) => setSelectedStaff(e.target.value === '' ? '' : Number(e.target.value))}
              className="w-full border border-gray-300 rounded-md px-3 py-2"
              required
              disabled={staffList.length <= 1}
            >
              <option value="">選択してください</option>
              {staffList.map((staff) => (
                <option key={staff.id} value={staff.id}>
                  {staff.name} ({staff.department} - {staff.group})
                </option>
              ))}
            </select>
          </div>

          {/* ステータス選択 */}
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              ステータス
            </label>
            <select
              value={selectedStatus}
              onChange={(e) => setSelectedStatus(e.target.value)}
              className="w-full border border-gray-300 rounded-md px-3 py-2"
              required
            >
              <option value="">選択してください</option>
              {availableStatuses.map((status) => (
                <option key={status} value={status}>
                  {capitalizeStatus(status)}
                </option>
              ))}
            </select>
          </div>

          {/* 開始時刻 */}
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              開始時刻
            </label>
            <select
              value={startTime}
              onChange={(e) => {
                const newStartTime = Number(e.target.value);
                setStartTime(newStartTime);
                if (newStartTime >= endTime) {
                  setEndTime(Math.min(newStartTime + 1, 21));
                }
              }}
              className="w-full border border-gray-300 rounded-md px-3 py-2"
            >
              {timeOptions.slice(0, -1).map((option) => (
                <option key={option.value} value={option.value}>
                  {option.label}
                </option>
              ))}
            </select>
          </div>

          {/* 終了時刻 */}
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">
              終了時刻
            </label>
            <select
              value={endTime}
              onChange={(e) => setEndTime(Number(e.target.value))}
              className="w-full border border-gray-300 rounded-md px-3 py-2"
            >
              {timeOptions.filter(option => option.value > startTime).map((option) => (
                <option key={option.value} value={option.value}>
                  {option.label}
                </option>
              ))}
            </select>
          </div>

          {/* メモ */}
          {(selectedStatus === 'meeting' || selectedStatus === 'training') && (
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                メモ
              </label>
              <input
                type="text"
                value={memo}
                onChange={(e) => setMemo(e.target.value)}
                className="w-full border border-gray-300 rounded-md px-3 py-2"
                placeholder="詳細を入力..."
              />
            </div>
          )}

          {/* ボタン */}
          <div className="flex space-x-3 pt-4">
            <button
              type="button"
              onClick={onClose}
              className="flex-1 px-4 py-2 border border-gray-300 rounded-md text-gray-700 hover:bg-gray-50"
            >
              キャンセル
            </button>
            <button
              type="submit"
              className="flex-1 px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700"
            >
              {scheduleToEdit ? '更新' : '追加'}
            </button>
          </div>
        </form>
      </div>
    </div>,
    document.body
  );
};

// ConfirmationModal コンポーネント
const ConfirmationModal = ({ isOpen, onClose, onConfirm, message }: { 
  isOpen: boolean; 
  onClose: () => void; 
  onConfirm: () => void; 
  message: string; 
}) => {
  if (!isOpen) return null;

  return createPortal(
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <div className="bg-white rounded-lg p-6 w-full max-w-sm">
        <h3 className="text-lg font-medium text-gray-900 mb-4">
          確認
        </h3>
        <p className="text-sm text-gray-500 mb-6">
          {message}
        </p>
        <div className="flex space-x-3">
          <button
            type="button"
            onClick={onClose}
            className="flex-1 px-4 py-2 border border-gray-300 rounded-md text-gray-700 hover:bg-gray-50"
          >
            キャンセル
          </button>
          <button
            type="button"
            onClick={onConfirm}
            className="flex-1 px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700"
          >
            削除
          </button>
        </div>
      </div>
    </div>,
    document.body
  );
};

export default PersonalSchedulePage;
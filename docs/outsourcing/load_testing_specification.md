# 負荷テスト仕様書 - 出社状況管理ボード

## 概要

出社状況管理ボードの300名企業での実運用に向け、WebSocket同時接続限界とシステム全体の性能特性を正確に測定するための包括的な負荷テスト仕様を定義する。

## 1. テスト目的・背景

### 1.1 主要目的
- **WebSocket同時接続限界の特定**: 現在不明な実際の接続数制限を測定
- **N×N通信問題の定量化**: 全クライアントブロードキャストによる性能劣化点の特定
- **300名企業対応の検証**: 設計目標である300名同時利用での動作確認
- **受付チーム業務継続性の保証**: 重要業務への影響評価

### 1.2 現在の課題
```yaml
技術的課題:
  - WebSocket同時接続限界: 不明（負荷テスト未実施）
  - 全クライアントブロードキャスト: N×N通信による指数的負荷増加
  - 実際のメモリ・CPU消費: 長時間運用での増加傾向未検証
  - データベース負荷: 履歴データ蓄積による性能影響

業務要件:
  - 受付チーム: リアルタイム更新遅延100ms以内必須
  - ピーク時間: 9:00-10:00、17:00-18:00の高負荷対応
  - 可用性: 平日業務時間中99.9%稼働率必要
```

## 2. テスト環境・構成

### 2.1 テスト環境仕様
```yaml
ハードウェア構成:
  CPU: 8コア（3.0GHz）
  メモリ: 32GB
  ストレージ: 500GB SSD
  ネットワーク: 1Gbps

ソフトウェア構成:
  OS: Ubuntu 22.04 LTS
  Docker: 24.x + Docker Compose v2
  Node.js: 18.x LTS
  PostgreSQL: 15.x
```

### 2.2 テスト実行基盤
```yaml
負荷生成ツール:
  - Artillery.io（WebSocket負荷テスト）
  - Apache Bench（HTTP API負荷テスト）
  - pgbench（PostgreSQL負荷テスト）

監視ツール:
  - htop / top（リアルタイムリソース監視）
  - Docker stats（コンテナリソース監視）
  - PostgreSQL pg_stat_activity（DB監視）
  - ブラウザ開発者ツール（WebSocket通信監視）

データ収集:
  - CPU使用率（1秒間隔）
  - メモリ使用量（1秒間隔）
  - WebSocket接続数（リアルタイム）
  - API応答時間（全リクエスト）
  - データベース接続プール状況
```

## 3. テストシナリオ設計

### 3.1 WebSocket同時接続テスト

#### シナリオ1: 段階的接続増加テスト
```yaml
目的: WebSocket接続限界の特定
手順:
  1. 10接続から開始
  2. 10接続ずつ段階的に増加（10, 20, 30, 40, 50...）
  3. 各段階で5分間安定動作確認
  4. エラー率5%または応答時間1秒超過で限界判定

測定項目:
  - 同時接続数
  - WebSocket接続成功率
  - メッセージ送受信遅延
  - CPU・メモリ使用率
  - コネクション確立時間

期待結果:
  - 安定動作可能な最大同時接続数
  - 性能劣化開始点の特定
  - リソース使用量の変化傾向
```

#### シナリオ2: 実業務パターンテスト
```yaml
目的: 300名企業での実際の利用パターン再現
接続パターン:
  - 総利用者: 300名
  - 同時接続: 50-100名（16-33%想定）
  - 受付チーム: 5名（常時接続・最優先）
  - 一般ユーザー: 45-95名（断続的接続）

時間パターン:
  - 平常時: 30名接続
  - ピーク時: 100名接続（9:00-10:00、17:00-18:00）
  - 昼休み: 10名接続

操作パターン:
  - スケジュール更新: 5件/分
  - ページ遷移: 20回/分
  - リアルタイム受信: 常時
```

### 3.2 API負荷テスト

#### シナリオ3: REST API負荷テスト
```yaml
目的: バックエンドAPI性能の測定
テスト対象API:
  - /api/schedules/unified（最重要・高負荷API）
  - /api/schedules（CRUD操作）
  - /api/staff（スタッフ情報取得）

負荷パターン:
  - 同時リクエスト: 1, 5, 10, 20, 50, 100
  - 継続時間: 各パターン10分間
  - リクエスト間隔: 1秒間隔

測定項目:
  - 応答時間（平均・95パーセンタイル・最大）
  - スループット（req/sec）
  - エラー率
  - データベース接続プール使用率
```

### 3.3 データベース負荷テスト

#### シナリオ4: PostgreSQL性能テスト
```yaml
目的: データベース層の性能限界測定
テスト内容:
  - 統合クエリ負荷（2層データレイヤー）
  - 履歴データ検索負荷
  - 同時書き込み性能
  - 長期運用データ量での性能

負荷パターン:
  - 同時接続: 10, 25, 50, 100, 200
  - クエリタイプ: SELECT（70%）、INSERT/UPDATE（25%）、DELETE（5%）
  - データ量: 現在データ + 1年分履歴データ

測定項目:
  - クエリ応答時間
  - 同時接続数
  - ロック待機時間
  - インデックス効率
```

## 4. 性能基準値・合格基準

### 4.1 WebSocket性能基準
```yaml
最小要件（Must）:
  - 同時接続数: 50接続以上
  - メッセージ遅延: 200ms以下
  - 接続安定性: 99%以上
  - メモリ使用量: 8GB以下

目標値（Should）:
  - 同時接続数: 100接続以上
  - メッセージ遅延: 100ms以下
  - 接続安定性: 99.9%以上
  - メモリ使用量: 6GB以下

理想値（Could）:
  - 同時接続数: 200接続以上
  - メッセージ遅延: 50ms以下
  - 接続安定性: 99.99%以上
  - メモリ使用量: 4GB以下
```

### 4.2 API性能基準
```yaml
最小要件:
  - 応答時間: 500ms以下（95パーセンタイル）
  - スループット: 100 req/sec以上
  - エラー率: 1%以下

目標値:
  - 応答時間: 200ms以下（95パーセンタイル）
  - スループット: 500 req/sec以上
  - エラー率: 0.1%以下
```

### 4.3 データベース性能基準
```yaml
最小要件:
  - 統合クエリ応答: 100ms以下
  - 同時接続: 100接続対応
  - ロック待機: 50ms以下

目標値:
  - 統合クエリ応答: 50ms以下
  - 同時接続: 200接続対応
  - ロック待機: 10ms以下
```

## 5. テスト実行計画

### 5.1 テストフェーズ

#### Phase 1: 基盤性能測定（1-2日）
```yaml
Day 1:
  - 環境構築・初期設定確認
  - 単体コンポーネント性能測定
  - ベースライン性能記録

Day 2:
  - WebSocket段階的接続テスト（シナリオ1）
  - 限界点特定・初期分析
```

#### Phase 2: 実業務負荷測定（2-3日）
```yaml
Day 3:
  - 実業務パターンテスト（シナリオ2）
  - ピーク時負荷再現

Day 4:
  - API負荷テスト（シナリオ3）
  - データベース負荷テスト（シナリオ4）

Day 5:
  - 長時間安定性テスト（12時間連続）
  - メモリリーク・パフォーマンス劣化確認
```

#### Phase 3: 限界・異常系テスト（1-2日）
```yaml
Day 6:
  - 限界値超過テスト
  - 異常系・復旧テスト
  
Day 7:
  - 結果分析・レポート作成
  - 改善提案策定
```

### 5.2 テスト自動化スクリプト

#### WebSocket負荷テスト（Artillery）
```yaml
# websocket-load-test.yml
config:
  target: 'http://localhost:3002'
  socketio:
    path: '/socket.io'
  phases:
    - duration: 300
      arrivalRate: 10
      rampTo: 50
  processor: './test-processor.js'

scenarios:
  - name: 'WebSocket接続テスト'
    weight: 100
    engine: socketio
    steps:
      - emit:
          channel: 'schedule:new'
          data:
            staffId: 1
            date: '2025-07-10'
            status: '勤務'
      - wait: 5
      - emit:
          channel: 'schedule:updated'
          data:
            id: 1
            status: '早退'
```

#### API負荷テスト（Apache Bench）
```bash
#!/bin/bash
# api-load-test.sh

echo "=== API負荷テスト開始 ==="

# 統合スケジュールAPI負荷テスト
for concurrent in 1 5 10 20 50; do
    echo "同時接続数: $concurrent"
    ab -n 1000 -c $concurrent \
       -H "Content-Type: application/json" \
       "http://localhost:3002/api/schedules/unified?date=2025-07-10" \
       > results/api_unified_${concurrent}.txt
    sleep 30
done

# CRUD操作負荷テスト
for concurrent in 1 5 10 20; do
    echo "CRUD負荷テスト: $concurrent"
    ab -n 500 -c $concurrent \
       -p schedule.json -T "application/json" \
       "http://localhost:3002/api/schedules" \
       > results/api_crud_${concurrent}.txt
    sleep 30
done
```

#### データベース負荷テスト（pgbench）
```sql
-- db-load-test.sql
\set staffid random(1, 300)
\set date_str '2025-07-' || (10 + random(0, 20))

-- 統合クエリ負荷テスト
SELECT 
  s.id, s.name, s.department,
  c.mondayHours, c.tuesdayHours,
  a.status, a.start, a.end
FROM staff s
LEFT JOIN contracts c ON s.id = c.staffId
LEFT JOIN adjustments a ON s.id = a.staffId 
  AND a.date = :'date_str'
WHERE s.id = :staffid;

-- 書き込み負荷テスト（10%の確率）
\if random(1, 10) = 1
INSERT INTO adjustments (staffId, date, status, start, end)
VALUES (:staffid, :'date_str', '勤務', '09:00:00', '18:00:00')
ON CONFLICT (staffId, date) DO UPDATE SET
  status = EXCLUDED.status;
\endif
```

## 6. 結果記録・分析

### 6.1 測定結果記録フォーマット

#### WebSocket性能記録
```yaml
# websocket_results_YYYYMMDD.yml
テスト日時: 2025-07-10T10:00:00Z
環境情報:
  CPU: 8コア利用可能
  メモリ: 32GB利用可能
  負荷生成マシン: 別サーバー

結果:
  最大安定接続数: XX接続
  性能劣化開始点: XX接続
  限界点（エラー率5%）: XX接続
  
  接続段階別測定:
    - 接続数: 10
      CPU使用率: XX%
      メモリ使用量: XXGB
      平均遅延: XXms
      エラー率: XX%
    
    - 接続数: 50
      CPU使用率: XX%
      メモリ使用量: XXGB
      平均遅延: XXms
      エラー率: XX%
      
  推奨運用値: XX接続（安全マージン20%）
  改善提案:
    - Redis導入によるクラスタリング
    - 接続数制限実装
    - 監視アラート設定
```

#### API性能記録
```yaml
# api_results_YYYYMMDD.yml
API: /api/schedules/unified
負荷パターン: 同時XX接続、継続10分

結果:
  応答時間:
    平均: XXms
    95パーセンタイル: XXms
    99パーセンタイル: XXms
    最大: XXms
  
  スループット: XX req/sec
  エラー率: XX%
  
  リソース使用状況:
    CPU最大: XX%
    メモリ最大: XXGB
    DB接続プール: XX/200使用
```

### 6.2 分析・評価基準

#### 合格判定マトリックス
```yaml
WebSocket接続テスト:
  ✅ 合格: 50接続以上で安定動作
  ⚠️  要改善: 30-49接続で安定動作
  ❌ 不合格: 30接続未満で限界

API性能テスト:
  ✅ 合格: 応答時間200ms以下、エラー率0.1%以下
  ⚠️  要改善: 応答時間500ms以下、エラー率1%以下
  ❌ 不合格: 応答時間500ms超過またはエラー率1%超過

長時間安定性:
  ✅ 合格: 12時間連続でメモリ増加10%以内
  ⚠️  要改善: メモリ増加10-20%
  ❌ 不合格: メモリ増加20%超過またはクラッシュ
```

### 6.3 改善提案テンプレート

```yaml
# improvement_proposals_YYYYMMDD.yml
測定結果サマリー:
  WebSocket最大接続数: XX接続
  主要ボトルネック: [CPU/Memory/Network/DB]
  目標達成状況: [達成/一部達成/未達成]

即座改善（1週間以内）:
  - 接続数制限実装: XX接続で制限
  - 監視アラート設定: CPU XX%、メモリ XXGBで警告
  - [その他具体的改善案]

中期改善（1ヶ月以内）:
  - Redis導入によるWebSocketクラスタリング
  - データベースインデックス最適化
  - [その他構造的改善案]

長期改善（3ヶ月以内）:
  - 水平スケーリング対応
  - マイクロサービス分離検討
  - [その他抜本的改善案]

運用推奨値:
  - WebSocket同時接続制限: XX接続
  - 監視閾値: CPU XX%、メモリ XXGBで警告
  - 定期再起動: [必要/不要] XX時間間隔
```

## 7. 継続監視・運用への反映

### 7.1 本番環境監視設定
```yaml
WebSocket監視:
  - 同時接続数: 閾値XX接続で警告
  - メッセージ遅延: 100ms超過で警告
  - 接続失敗率: 1%超過でアラート

API監視:
  - 応答時間: 500ms超過で警告
  - エラー率: 1%超過でアラート
  - スループット: XX req/sec下回りで注意

リソース監視:
  - CPU使用率: 80%で警告、90%でアラート
  - メモリ使用率: 85%で警告、95%でアラート
  - ディスク使用率: 90%で警告
```

### 7.2 定期性能検証
```yaml
月次性能確認:
  - WebSocket接続テスト（縮小版）
  - API応答時間確認
  - データベース性能確認

四半期負荷テスト:
  - 本格負荷テスト再実行
  - ベンチマーク比較
  - 改善効果測定

年次性能評価:
  - 全面的性能再評価
  - 拡張性計画見直し
  - 技術刷新検討
```

## 8. リスク・制約事項

### 8.1 テスト実行リスク
```yaml
技術的リスク:
  - 負荷テストによるシステム停止リスク
  - データ破損・整合性問題
  - ネットワーク帯域占有

軽減策:
  - 専用テスト環境での実行
  - データベースバックアップ事前取得
  - 本番環境への影響監視
```

### 8.2 測定制約
```yaml
環境制約:
  - テスト環境と本番環境の差異
  - 負荷生成ツールの限界
  - 測定精度の制限

業務制約:
  - 受付チーム業務への影響最小化
  - テスト実行時間の制限
  - リソース使用制限
```

---

**文書バージョン**: 1.0.0  
**作成日**: 2025-07-10  
**対象**: システム開発・運用チーム  
**承認**: 要プロジェクトマネージャー・システム管理者承認

この負荷テスト仕様書により、出社状況管理ボードの実際の性能限界を正確に測定し、300名企業での安定運用を実現するための根拠データを取得できます。特にWebSocket同時接続限界の特定は、受付チーム業務の継続性確保にとって極めて重要です。